//
//  Test.swift
//  Test
//
//  Created by ayan Chakraborty on 05/11/25.
//

import Foundation
import Foundation
import UIKit // For device info
import BackgroundTasks
import os

// MARK: - Logging Helper

enum LogCategory {
    static let eventLogger = "EventLogger"
    static let network = "Network"
    static let store = "EventStore"
    static let networkMonitor = "NetworkMonitor"
}

struct Log {
    private static var subsystem: String { EventLogger.bundleBase }

    static func info(_ message: String, category: String = LogCategory.eventLogger) {
        if #available(iOS 14.0, *) {
            let logger = Logger(subsystem: subsystem, category: category)
            logger.info("\(message, privacy: .public)")
        } else {
            print("[INFO] [\(category)] \(message)")
        }
    }

    static func error(_ message: String, category: String = LogCategory.eventLogger) {
        if #available(iOS 14.0, *) {
            let logger = Logger(subsystem: subsystem, category: category)
            logger.error("\(message, privacy: .public)")
        } else {
            print("[ERROR] [\(category)] \(message)")
        }
    }
}

    ///
    /// EventLogger: The main public interface for logging events.
    ///
    /// This singleton class orchestrates event logging, persistence, and batch uploading.
    ///
    /// ## Usage:
    ///
    /// 1. **Configure on app launch (e.g., in AppDelegate):**
    ///   ```swift
    ///   EventLogger.shared.configure(
    ///       apiEndpoint: URL(string: "[https://api.yourdomain.com/v1/logs](https://api.yourdomain.com/v1/logs)")!,
    ///       mtopSecKey: "YOUR_SECRET_KEY"
    ///   )
    ///   ```
    ///
    /// 2. **Update user info on login/logout:**
    ///   ```swift
    ///   EventLogger.shared.setUserInfo(userId: 1234, orgId: 5678)
    ///   ```
    ///   ```swift
    ///   EventLogger.shared.clearUserInfo() // On logout
    ///   ```
    ///
    /// 3. **Log events anywhere in your app:**
    ///   ```swift
    ///   EventLogger.shared.logEvent(name: "course_viewed", type: "course")
    ///   ```
    ///
    /// 4. **In your AppDelegate:**
    ///   ```swift
    ///   func application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -> Void) {
    ///       if identifier == EventNetworkManager.backgroundSessionIdentifier {
    ///           EventLogger.shared.setBackgroundSessionCompletionHandler(completionHandler)
    ///       }
    ///   }
    ///   ```
    ///
public class EventLogger: NSObject, EventNetworkManagerDelegate {

        // MARK: - Public Properties

        /// Shared singleton instance
    public static let shared = EventLogger()

        // MARK: - Private Properties

    private var isConfigured: Bool = false
    private var apiEndpoint: URL!
    private var mtopSecKey: String!

        // User context
    private var userId: Int?
    private var orgId: Int?

        // Services
    private let eventStore = EventStore()
    private let networkManager = EventNetworkManager() // Now instantiated
    private let networkMonitor = NetworkMonitor()

        // State & Concurrency
        private let uploadQueue = DispatchQueue(label: EventLogger.bundleBase + ".eventLogger.uploadQueue", qos: .background)
    private var isCurrentlyUploading = false

        /// Timer is now only for *triggering* an upload, not for the upload itself.
    private var uploadTimer: Timer?

        /// Maximum number of events to send in a single batch.
    // Dynamic & adaptive batch sizing (configurable)
    private var baseMinBatchSize = 50
    private var baseMaxBatchSize = 60
    private let initialMaxBatchSize = 60 // baseline for shrink logic
    private var adaptiveAbsoluteMaxBatchSize = 200 // upper bound after growth
    private var consecutiveSuccesses = 0
    private let successThresholdForGrowth = 3
    private let batchGrowthStep = 10
    private let batchShrinkStep = 10
    private var currentMinBatchSize: Int { baseMinBatchSize }
    private var currentMaxBatchSize: Int { baseMaxBatchSize }

        /// How often to *check* if we should upload.
    private var uploadInterval: TimeInterval = 300.0 // 5 minutes (configurable)

    // Retention / store size guard
    private var maxStoreFileBytes: Int = 512 * 1024 // 512 KB default (configurable)

    // Retry policy
    private let maxRetryAttempts = 3
    private let baseRetryDelay: TimeInterval = 5 // seconds, exponential backoff
    private let retryStore = RetryStateStore() // persistent retry attempts

    // Base bundle identifier fallback (single source of truth for IDs)
    public static let bundleBase: String = Bundle.main.bundleIdentifier ?? "bundle.missing"
    // BGTaskScheduler identifier (derived from base)
    public static var backgroundProcessingTaskIdentifier: String = bundleBase + ".eventLogger.upload"

#if canImport(BackgroundTasks)
    @available(iOS 13.0, *)
    private var currentBGProcessingTask: BGProcessingTask?
#endif

        // MARK: - Initialization

    private override init() {
        super.init()

            // Set the logger as the network manager's delegate
        self.networkManager.delegate = self

            // Start monitoring network status
        networkMonitor.startMonitoring()

            // Add an observer to trigger uploads when network becomes available
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(onNetworkStatusChanged),
            name: .networkStatusChanged,
            object: nil
        )

            // Register and schedule background processing (iOS 13+). Fallback to timer otherwise.
        if #available(iOS 13.0, *) {
            registerBackgroundTasks()
            scheduleBackgroundUpload()
        } else {
            setupUploadTimer()
        }
    }

    deinit {
        networkMonitor.stopMonitoring()
        uploadTimer?.invalidate()
        NotificationCenter.default.removeObserver(self)
    }

        // MARK: - Public Configuration

        /// Configures the EventLogger with your API endpoint and keys.
        /// Call this once on app launch.
    public func configure(apiEndpoint: URL, mtopSecKey: String) {
        self.apiEndpoint = apiEndpoint
        self.mtopSecKey = mtopSecKey
        self.isConfigured = true
    Log.info("Configured.", category: LogCategory.eventLogger)

            // Attempt an upload on configuration, in case we have pending events.
        triggerBatchUpload()

            // Ensure a background task is scheduled as a time trigger
        if #available(iOS 13.0, *) {
            scheduleBackgroundUpload()
        }
    }

        /// Sets the user-specific identifiers. Call this on user login.
    public func setUserInfo(userId: Int, orgId: Int) {
        self.userId = userId
        self.orgId = orgId
    Log.info("UserInfo Set: userId=\(userId)", category: LogCategory.eventLogger)
            // Trigger an upload in case events were logged anonymously
        triggerBatchUpload()

            // Also schedule background upload to run soon
        if #available(iOS 13.0, *) {
            scheduleBackgroundUpload(earliestBeginDate: Date(timeIntervalSinceNow: 60))
        }
    }

        /// Clears user-specific identifiers. Call this on user logout.
    public func clearUserInfo() {
        self.userId = nil
        self.orgId = nil
    Log.info("UserInfo Cleared.", category: LogCategory.eventLogger)
    }

        /// Updates dynamic upload-related configuration at runtime.
        /// Any parameter left nil remains unchanged.
    public func updateUploadConfiguration(
        minBatchSize: Int? = nil,
        maxBatchSize: Int? = nil,
        uploadInterval: TimeInterval? = nil,
        maxStoreFileBytes: Int? = nil,
        adaptiveAbsoluteMax: Int? = nil
    ) {
        if let minBatchSize, minBatchSize > 0 { self.baseMinBatchSize = minBatchSize }
        if let maxBatchSize, maxBatchSize >= self.baseMinBatchSize { self.baseMaxBatchSize = maxBatchSize }
        if let adaptiveAbsoluteMax, adaptiveAbsoluteMax >= self.baseMaxBatchSize { self.adaptiveAbsoluteMaxBatchSize = adaptiveAbsoluteMax }
        if let uploadInterval, uploadInterval >= 30 { // guard against too frequent
            self.uploadInterval = uploadInterval
            // Reschedule periodic mechanism
            if #available(iOS 13.0, *) {
                scheduleBackgroundUpload()
            } else {
                setupUploadTimer()
            }
        }
        if let maxStoreFileBytes, maxStoreFileBytes > 1024 { // minimum 1KB
            self.maxStoreFileBytes = maxStoreFileBytes
        }
        Log.info("Updated upload configuration: min=\(baseMinBatchSize), max=\(baseMaxBatchSize), interval=\(self.uploadInterval)s, storeLimit=\(self.maxStoreFileBytes) bytes, adaptiveMax=\(adaptiveAbsoluteMaxBatchSize)", category: LogCategory.eventLogger)
    }

        /// Connects the AppDelegate's completion handler to the network manager.
    public func setBackgroundSessionCompletionHandler(_ handler: @escaping () -> Void) {
        networkManager.backgroundSessionCompletionHandler = handler
    }

        // MARK: - Public Event Logging

        /// Logs a new event.
        /// This method is lightweight and returns immediately.
        /// - Parameters:
        ///   - name: The name of the event (e.g., "new", "course_viewed").
        ///   - type: The type of the event (e.g., "course").
    public func logEvent(name: String, type: String) {
        guard isConfigured else {
            Log.error("Must be configured before logging events.", category: LogCategory.eventLogger)
            return
        }

        let event = Event(event_name: name, event_type: type)

            // Persist the event in the background
        DispatchQueue.global(qos: .background).async { [weak self] in
            guard let self = self else { return }

            self.eventStore.saveEvent(event)
            let currentCount = self.eventStore.getEventCount()
            Log.info("Event logged: \(name). Total pending: \(currentCount)", category: LogCategory.eventLogger)

                // Size trigger: If we've hit the minimum batch threshold, trigger an upload immediately
            if currentCount >= self.minBatchSize {
                self.triggerBatchUpload()
                if #available(iOS 13.0, *) {
                        // Nudge the scheduler to wake us if we're in background
                    self.scheduleBackgroundUpload(earliestBeginDate: Date(timeIntervalSinceNow: 60))
                }
            }
        }
    }

        // MARK: - Batch Upload Logic

    @objc private func onNetworkStatusChanged() {
        if networkMonitor.isOnline {
            Log.info("Network is back online. Triggering upload.", category: LogCategory.eventLogger)
            triggerBatchUpload()
        } else {
            Log.info("Network is offline.", category: LogCategory.eventLogger)
        }
    }

    private func setupUploadTimer() {
        uploadTimer?.invalidate()
            // Use a main-thread timer to schedule the background work
        DispatchQueue.main.async {
            self.uploadTimer = Timer.scheduledTimer(
                withTimeInterval: self.uploadInterval,
                repeats: true
            ) { [weak self] _ in
                Log.info("Periodic upload timer fired.", category: LogCategory.eventLogger)
                self?.triggerBatchUpload()
            }
        }
    }

        /// Triggers a batch upload process on a dedicated background queue.
    public func triggerBatchUpload() {
        uploadQueue.async { [weak self] in
            self?.performUpload()
        }
    }

        // Internal accessors for collaborators in this file (EventStore)
    fileprivate func maxStoreFileBytesAccessor() -> Int { maxStoreFileBytes }
    fileprivate func baseMinBatchSizeAccessor() -> Int { baseMinBatchSize }

        /// The core upload logic. Runs on the `uploadQueue`.
    private func performUpload() {
            // Ensure all conditions are met for an upload
        guard isConfigured else { return }

            // This check is now just a safeguard.
            // A background task might already be running.
        guard !isCurrentlyUploading else {
            Log.info("Upload already in progress.", category: LogCategory.eventLogger)
            return
        }

        guard networkMonitor.isOnline else {
            Log.info("Upload skipped, network is offline.", category: LogCategory.eventLogger)
            return
        }

            // A user must be set to send logs
        guard let userId = self.userId, let orgId = self.orgId else {
            Log.info("Upload skipped, user/org ID not set.", category: LogCategory.eventLogger)
            return
        }

            // Determine dynamic batch size between 50â€“60, limited by pending count
        let pendingCount = eventStore.getEventCount()
        guard pendingCount > 0 else { return }

    let upperBound = max(1, min(currentMaxBatchSize, pendingCount))
    let lowerBound = min(currentMinBatchSize, upperBound)
        let dynamicLimit = Int.random(in: lowerBound...upperBound)
        let batch = eventStore.getBatch(limit: dynamicLimit)

        guard !batch.isEmpty else {
                // print("EventLogger: No events to upload.")
            return
        }

    Log.info("Starting upload of \(batch.count) events...", category: LogCategory.eventLogger)
        isCurrentlyUploading = true

            // Kick off upload with retry management
        sendBatch(batch, userId: userId, orgId: orgId)
    }

        /// Builds and sends a batch, tracking retry attempts by a stable batch key.
    private func sendBatch(_ events: [Event], userId: Int, orgId: Int) {
        guard !events.isEmpty else { return }

        let requestPayload = EventBatchRequest(
            mtop_sec_key: self.mtopSecKey,
            user_id: userId,
            org_id: orgId,
            device_os: "\(UIDevice.current.systemName) \(UIDevice.current.systemVersion)",
            device: UIDevice.current.model,
            events: events
        )

        isCurrentlyUploading = true
        networkManager.sendEvents(payload: requestPayload, to: apiEndpoint)
    }

        /// Computes a stable key for a batch to track retry counts.
    private func batchKey(for events: [Event]) -> String {
        var hasher = Hasher()
        for ev in events { hasher.combine(ev) }
        return String(hasher.finalize())
    }

        /// Handles retry with exponential backoff; gives up after maxRetryAttempts and defers to next schedule.
    private func handleRetry(for events: [Event], lastError: EventLoggerError) {
        let key = batchKey(for: events)
        let attempts = retryStore.getAttempts(for: key)

        guard attempts < maxRetryAttempts else {
            Log.info("Max retry attempts reached for batch (\(events.count)). Deferring to next schedule.", category: LogCategory.eventLogger)
            retryStore.clearAttempts(for: key)
            isCurrentlyUploading = false
            // Schedule next background attempt later
            if #available(iOS 13.0, *) { scheduleBackgroundUpload() }
            completeBGTaskIfIdle()
            return
        }

        let delay = baseRetryDelay * pow(2, Double(attempts))
        Log.info("Retrying batch (\(events.count)) in \(delay)s. Attempt \(attempts + 1)/\(maxRetryAttempts)", category: LogCategory.eventLogger)
        retryStore.setAttempts(for: key, attempts: attempts + 1)

        uploadQueue.asyncAfter(deadline: .now() + delay) { [weak self] in
            guard let self = self else { return }
            guard self.isConfigured, self.networkMonitor.isOnline, let userId = self.userId, let orgId = self.orgId else {
                self.isCurrentlyUploading = false
                self.completeBGTaskIfIdle()
                return
            }
            self.sendBatch(events, userId: userId, orgId: orgId)
        }
    }

        // MARK: - EventNetworkManagerDelegate

    func batchUploadDidSucceed(for events: [Event]) {
        Log.info("Batch upload success for \(events.count) events.", category: LogCategory.eventLogger)
            // This delegate method can be called on any thread.
            // Dispatch to our store's queue for removal.
        self.eventStore.removeEvents(events)

            // Check if more events are pending and trigger another upload
        uploadQueue.async { [weak self] in
            guard let self = self else { return }
            // Clear retry state for this batch if any
            let key = self.batchKey(for: events)
            self.retryStore.clearAttempts(for: key)

            self.isCurrentlyUploading = false

            // Adaptive growth logic
            self.consecutiveSuccesses += 1
            if self.consecutiveSuccesses >= self.successThresholdForGrowth && self.baseMaxBatchSize < self.adaptiveAbsoluteMaxBatchSize {
                self.baseMaxBatchSize = min(self.adaptiveAbsoluteMaxBatchSize, self.baseMaxBatchSize + self.batchGrowthStep)
                self.consecutiveSuccesses = 0
                Log.info("Adaptive batch: increased max batch size to \(self.baseMaxBatchSize)", category: LogCategory.eventLogger)
            }

            if self.eventStore.getEventCount() > 0 {
                print("EventLogger: More events pending. Triggering next batch.")
                self.performUpload() // Chain the next upload
            } else {
                self.completeBGTaskIfIdle()
            }
        }
    }

    func batchUploadDidFail(for events: [Event], error: EventLoggerError) {
        Log.error("Batch upload failed for \(events.count) events. Error: \(error)", category: LogCategory.eventLogger)
            // On failure, do nothing. The events remain in the store for the next attempt.
        // Adaptive shrink logic (only once per failure event)
        if baseMaxBatchSize > initialMaxBatchSize {
            baseMaxBatchSize = max(initialMaxBatchSize, baseMaxBatchSize - batchShrinkStep)
            Log.info("Adaptive batch: decreased max batch size to \(baseMaxBatchSize)", category: LogCategory.eventLogger)
        }
        consecutiveSuccesses = 0
        uploadQueue.async { [weak self] in
            self?.handleRetry(for: events, lastError: error)
        }
    }

#if canImport(BackgroundTasks)
    // MARK: - BGTaskScheduler integration (iOS 13+)

    @available(iOS 13.0, *)
    private func registerBackgroundTasks() {
        BGTaskScheduler.shared.register(forTaskWithIdentifier: Self.backgroundProcessingTaskIdentifier, using: nil) { [weak self] task in
            guard let self = self, let processingTask = task as? BGProcessingTask else {
                task.setTaskCompleted(success: false)
                return
            }
            self.handleBackgroundProcessing(task: processingTask)
        }
    }

    @available(iOS 13.0, *)
    public func scheduleBackgroundUpload(earliestBeginDate: Date? = nil) {
        let request = BGProcessingTaskRequest(identifier: Self.backgroundProcessingTaskIdentifier)
        request.requiresNetworkConnectivity = true
        request.requiresExternalPower = false
        if let earliest = earliestBeginDate {
            request.earliestBeginDate = earliest
        } else {
            // Add small jitter (+/- up to 10%) to avoid clustered wakeups across many installs
            let jitterFactor = Double.random(in: 0.9...1.1)
            request.earliestBeginDate = Date(timeIntervalSinceNow: uploadInterval * jitterFactor)
        }
        do {
            try BGTaskScheduler.shared.submit(request)
            print("EventLogger: BGProcessingTask scheduled (earliest: \(request.earliestBeginDate?.description ?? "n/a")).")
        } catch {
            print("EventLogger Error: Failed to schedule BGProcessingTask: \(error)")
        }
    }

    @available(iOS 13.0, *)
    private func handleBackgroundProcessing(task: BGProcessingTask) {
        print("EventLogger: BGProcessingTask started.")
        currentBGProcessingTask = task
        // Always schedule the next one
        scheduleBackgroundUpload()

        var expired = false
        task.expirationHandler = { [weak self] in
            expired = true
            print("EventLogger: BGProcessingTask expired by system.")
            self?.isCurrentlyUploading = false
        }

        // Start uploads; chain continues via delegate callbacks
        triggerBatchUpload()

        // Best-effort completion once idle
        uploadQueue.async { [weak self] in
            guard let self = self else { return }
            // Poll a few times to detect idle state quickly
            let checkInterval: TimeInterval = 2
            let maxChecks = 5
            var checks = 0
            func checkAndComplete() {
                guard checks < maxChecks else { return }
                checks += 1
                if expired {
                    task.setTaskCompleted(success: false)
                    self.currentBGProcessingTask = nil
                    return
                }
                if !self.isCurrentlyUploading {
                    let success = self.eventStore.getEventCount() == 0
                    task.setTaskCompleted(success: success)
                    self.currentBGProcessingTask = nil
                } else {
                    self.uploadQueue.asyncAfter(deadline: .now() + checkInterval) {
                        checkAndComplete()
                    }
                }
            }
            checkAndComplete()
        }
    }

    @available(iOS 13.0, *)
    private func completeCurrentBGTask(success: Bool) {
        if let task = currentBGProcessingTask {
            print("EventLogger: Completing BGProcessingTask (success=\(success)).")
            task.setTaskCompleted(success: success)
            currentBGProcessingTask = nil
        }
    }
#endif

        /// Completes BG task if no upload in progress and no pending events.
    private func completeBGTaskIfIdle() {
#if canImport(BackgroundTasks)
        if #available(iOS 13.0, *) {
            if !isCurrentlyUploading {
                let success = self.eventStore.getEventCount() == 0
                completeCurrentBGTask(success: success)
            }
        }
#endif
    }
}


import Foundation

    // MARK: - API Request Structures

    /// A single event to be logged.
public struct Event: Codable, Hashable {
    let event_name: String
    let event_type: String
}

    /// The main request body sent to the API.
struct EventBatchRequest: Codable {
    let mtop_sec_key: String
    let user_id: Int
    let org_id: Int
    let device_os: String
    let device: String
    let events: [Event]
}

    // MARK: - API Response Structures

    /// The expected successful response from the API.
struct SuccessResponse: Codable {
    let message: String
    let status: Int
}

    // MARK: - Custom Errors

enum EventLoggerError: Error {
    case apiError(message: String)
    case networkError(Error)
    case invalidResponse
    case encodingFailed
}

import Foundation

    ///
    /// EventStore: Handles thread-safe persistence of `Event` objects to the device's file system.
    ///
    /// This class ensures that all file I/O is performed on a dedicated serial queue
    /// to prevent race conditions.
    ///
class EventStore {

        /// A dedicated serial queue for all file read/write operations.
    private let persistenceQueue = DispatchQueue(label: EventLogger.bundleBase + ".eventStore.persistenceQueue")

        /// The URL for the JSON file where events are stored.
    private lazy var eventsFileURL: URL = {
        let fileManager = FileManager.default
            // Use Application Support directory, as it's not user-facing
        let appSupportURL = fileManager.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!
        let eventsDirectoryURL = appSupportURL.appendingPathComponent("EventLogger")

            // Create the directory if it doesn't exist
        if !fileManager.fileExists(atPath: eventsDirectoryURL.path) {
            do {
                try fileManager.createDirectory(at: eventsDirectoryURL, withIntermediateDirectories: true, attributes: nil)
            } catch {
                print("EventStore Error: Could not create directory at \(eventsDirectoryURL.path): \(error)")
            }
        }

        return eventsDirectoryURL.appendingPathComponent("pendingEvents.json")
    }()

    private let encoder = JSONEncoder()
    private let decoder = JSONDecoder()

        // MARK: - Public Methods

        /// Saves a single event to the persistent store.
        /// This operation is performed asynchronously on the persistence queue.
    func saveEvent(_ event: Event) {
        persistenceQueue.async {
            var allEvents = self.loadPendingEvents()
            allEvents.append(event)
            self.saveEventsToFile(allEvents)
            self.enforceSizeLimitIfNeeded()
        }
    }

        /// Returns the total count of pending events.
        /// This operation is performed synchronously on the persistence queue.
    func getEventCount() -> Int {
        var count = 0
        persistenceQueue.sync {
            count = self.loadPendingEvents().count
        }
        return count
    }

        /// Retrieves a batch of events to be sent, up to a specified limit.
        /// This does *not* remove the events from the store.
        /// This operation is performed synchronously on the persistence queue.
    func getBatch(limit: Int) -> [Event] {
        var batch: [Event] = []
        persistenceQueue.sync {
            let allEvents = self.loadPendingEvents()
            batch = Array(allEvents.prefix(limit))
        }
        return batch
    }

        /// Removes a specific batch of events from the store.
        /// This is called *after* a successful network upload.
        /// This operation is performed asynchronously on the persistence queue.
    func removeEvents(_ eventsToRemove: [Event]) {
        persistenceQueue.async {
                // Use a Set for efficient removal
            let eventsToRemoveSet = Set(eventsToRemove)
            if eventsToRemoveSet.isEmpty { return }

            var allEvents = self.loadPendingEvents()

                // Filter out the events that were successfully sent
            allEvents.removeAll { eventsToRemoveSet.contains($0) }

            self.saveEventsToFile(allEvents)
        }
    }

        // MARK: - Private Helpers (Must be called from persistenceQueue)

        /// Loads all events from the JSON file.
        /// **Warning:** Must only be called from within the `persistenceQueue`.
    private func loadPendingEvents() -> [Event] {
        do {
            let data = try Data(contentsOf: eventsFileURL)
            let events = try decoder.decode([Event].self, from: data)
            return events
        } catch {
                // If file doesn't exist or is corrupt, return an empty array
                // print("EventStore: Could not load events (\(error.localizedDescription)). Starting fresh.")
            return []
        }
    }

        /// Saves an array of events to the JSON file.
        /// **Warning:** Must only be called from within the `persistenceQueue`.
    private func saveEventsToFile(_ events: [Event]) {
        do {
            let data = try encoder.encode(events)
            try data.write(to: eventsFileURL, options: .atomic)
        } catch {
            print("EventStore Error: Could not save events to file: \(error)")
        }
    }

        /// Checks file size and trims oldest events if exceeding configured limit.
    private func enforceSizeLimitIfNeeded() {
        // Read size
        guard let attributes = try? FileManager.default.attributesOfItem(atPath: eventsFileURL.path),
              let fileSize = attributes[.size] as? NSNumber else { return }

        let limitBytes = EventLogger.shared.maxStoreFileBytesAccessor()
        guard fileSize.intValue > limitBytes else { return }

        // Load, trim oldest 20% until under limit or until only min batch remains.
        var events = loadPendingEvents()
        let minimumKeep = EventLogger.shared.baseMinBatchSizeAccessor()
        var trimmed = false
        while events.count > minimumKeep && (try? Data(contentsOf: eventsFileURL))?.count ?? 0 > limitBytes {
            let removeCount = max(1, events.count / 5)
            events.removeFirst(removeCount)
            saveEventsToFile(events)
            trimmed = true
        }
        if trimmed {
            Log.info("EventStore trimmed old events to enforce size limit (limit=\(limitBytes) bytes, remaining=\(events.count)).", category: LogCategory.store)
        }
    }
}

import Foundation

// MARK: - Retry State Store (persistent)

/// Persists retry attempts per batch key to disk so attempts survive restarts.
final class RetryStateStore {
    private let queue = DispatchQueue(label: EventLogger.bundleBase + ".eventLogger.retryStateQueue")
    private var cache: [String: Int] = [:]

    private lazy var fileURL: URL = {
        let fm = FileManager.default
        let base = fm.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!
        let dir = base.appendingPathComponent("EventLogger")
        if !fm.fileExists(atPath: dir.path) {
            try? fm.createDirectory(at: dir, withIntermediateDirectories: true)
        }
        return dir.appendingPathComponent("retryAttempts.json")
    }()

    init() {
        load()
    }

    func getAttempts(for key: String) -> Int {
        var v = 0
        queue.sync { v = cache[key] ?? 0 }
        return v
    }

    func setAttempts(for key: String, attempts: Int) {
        queue.async {
            self.cache[key] = attempts
            self.persist()
        }
    }

    func clearAttempts(for key: String) {
        queue.async {
            self.cache.removeValue(forKey: key)
            self.persist()
        }
    }

    private func load() {
        queue.sync {
            guard let data = try? Data(contentsOf: fileURL) else { return }
            if let decoded = try? JSONDecoder().decode([String: Int].self, from: data) {
                self.cache = decoded
            }
        }
    }

    private func persist() {
        let data = try? JSONEncoder().encode(cache)
        if let data { try? data.write(to: fileURL, options: .atomic) }
    }
}

    /// Delegate protocol for the EventNetworkManager to report back task completion.
protocol EventNetworkManagerDelegate: AnyObject {
        /// Called when a batch of events is successfully uploaded.
    func batchUploadDidSucceed(for events: [Event])
        /// Called when a batch upload fails.
    func batchUploadDidFail(for events: [Event], error: EventLoggerError)
}

    ///
    /// EventNetworkManager: Handles the network call to send a batch of events.
    ///
    /// This class is now an NSObject to conform to URLSessionTaskDelegate
    /// and manages a background URLSession.
    ///
class EventNetworkManager: NSObject, URLSessionTaskDelegate {

        /// A unique identifier for our background session (derived from EventLogger base)
        static var backgroundSessionIdentifier: String = EventLogger.bundleBase + ".eventLogger.backgroundSession"

    weak var delegate: EventNetworkManagerDelegate?

    private lazy var urlSession: URLSession = {
        let config = URLSessionConfiguration.background(withIdentifier: Self.backgroundSessionIdentifier)
        config.isDiscretionary = true // Let the OS optimize for performance vs. battery
        config.sessionSendsLaunchEvents = true
        return URLSession(configuration: config, delegate: self, delegateQueue: nil)
    }()

        /// A thread-safe dictionary to map a task identifier to the batch of events and the temp file URL it represents.
        /// [TaskIdentifier: (TempFileURL, EventsInBatch)]
    private var tasks = [Int: (URL, [Event])]()
    private let tasksQueue = DispatchQueue(label: EventLogger.bundleBase + ".eventNetworkManager.tasksQueue")

        /// Stores the completion handler from the AppDelegate.
    var backgroundSessionCompletionHandler: (() -> Void)?

    override init() {
        super.init()
            // Calling this ensures the session is created and can find orphaned tasks from a previous app launch.
        _ = self.urlSession
        print("EventNetworkManager initialized for background tasks.")
    }

        /// Creates a temporary file on disk for the upload task.
    private func createTempFile(for payload: EventBatchRequest) throws -> URL {
        let data = try JSONEncoder().encode(payload)
        let tempDir = FileManager.default.temporaryDirectory
        let fileName = UUID().uuidString + ".json"
        let tempFileURL = tempDir.appendingPathComponent(fileName)

        try data.write(to: tempFileURL, options: .atomic)
        return tempFileURL
    }

        /// Sends a batch of events to the specified API endpoint using a background task.
        /// This method returns immediately. Completion is handled by the delegate.
    func sendEvents(payload: EventBatchRequest, to url: URL) {

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        let tempFileURL: URL
        do {
            tempFileURL = try createTempFile(for: payload)
        } catch {
            print("EventNetworkManager Error: Failed to create temp file. \(error)")
            self.delegate?.batchUploadDidFail(for: payload.events, error: .encodingFailed)
            return
        }

            // Create an upload task from the file.
        let task = urlSession.uploadTask(with: request, fromFile: tempFileURL)

            // Store the task info
        tasksQueue.sync {
            tasks[task.taskIdentifier] = (tempFileURL, payload.events)
        }

        print("EventNetworkManager: Starting background upload task \(task.taskIdentifier) for \(payload.events.count) events.")
        task.resume()
    }

        // MARK: - URLSessionTaskDelegate

        /// This delegate method is called when a task completes, either successfully or with an error.
        /// This WILL be called in the background.
    func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {

            // Retrieve and remove the task info
        let taskInfo = tasksQueue.sync {
            tasks.removeValue(forKey: task.taskIdentifier)
        }

        guard let (tempFileURL, events) = taskInfo else {
            print("EventNetworkManager Error: Completed task \(task.taskIdentifier) not in dictionary. This is unexpected.")
            return
        }

            // Always clean up the temporary file
        try? FileManager.default.removeItem(at: tempFileURL)

            // Handle network error
        if let error = error {
            print("EventNetworkManager: Task \(task.taskIdentifier) failed with error: \(error.localizedDescription)")
            self.delegate?.batchUploadDidFail(for: events, error: .networkError(error))
            return
        }

            // Check HTTP response
        guard let httpResponse = task.response as? HTTPURLResponse else {
            print("EventNetworkManager: Task \(task.taskIdentifier) completed with invalid response.")
            self.delegate?.batchUploadDidFail(for: events, error: .invalidResponse)
            return
        }

        guard (200...299).contains(httpResponse.statusCode) else {
            print("EventNetworkManager: Task \(task.taskIdentifier) completed with status \(httpResponse.statusCode).")
            self.delegate?.batchUploadDidFail(for: events, error: .apiError(message: "Invalid status code: \(httpResponse.statusCode)"))
            return
        }

            // ---
            // Success!
            // ---
            // We don't check the response body here for background tasks,
            // as we can't get it from `didCompleteWithError`. A 2xx status is our success signal.
            // If you MUST parse the response, you need to implement `urlSession(_:dataTask:didReceive:data:)`.
            // For a simple "log and forget" system, this is usually sufficient.

        print("EventNetworkManager: Task \(task.taskIdentifier) completed successfully.")
        self.delegate?.batchUploadDidSucceed(for: events)
    }

        // MARK: - URLSessionDelegate

        /// This is called by the OS when all background tasks for this session are complete.
    func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {
        DispatchQueue.main.async { [weak self] in
            print("EventNetworkManager: All background tasks finished.")
            self?.backgroundSessionCompletionHandler?()
            self?.backgroundSessionCompletionHandler = nil
        }
    }
}


import Foundation
import Network

    /// Notification posted when the network status changes.
extension Notification.Name {
    static let networkStatusChanged = Notification.Name("networkStatusChanged")
}

    ///
    /// NetworkMonitor: A wrapper around `NWPathMonitor` to provide
    /// a simple `isOnline` property and post a notification on change.
    ///
class NetworkMonitor {

    private let monitor: NWPathMonitor
    private let queue: DispatchQueue

        /// `true` if the device has a viable network connection.
    public private(set) var isOnline: Bool = false

    init() {
        self.monitor = NWPathMonitor()
    self.queue = DispatchQueue(label: EventLogger.bundleBase + ".networkMonitorQueue")
    }

        /// Starts monitoring network path updates.
    func startMonitoring() {
        monitor.pathUpdateHandler = { [weak self] path in
            let newStatus = (path.status == .satisfied)

            if self?.isOnline != newStatus {
                self?.isOnline = newStatus

                    // Post a notification so other parts of the app can react
                NotificationCenter.default.post(
                    name: .networkStatusChanged,
                    object: nil,
                    userInfo: ["isOnline": newStatus]
                )
            }
        }
        monitor.start(queue: queue)
    }

        /// Stops monitoring network path updates.
    func stopMonitoring() {
        monitor.cancel()
    }
}
